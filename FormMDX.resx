<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TextBox1.Text" xml:space="preserve">
    <value>	Что такое DirectX?
	Библиотеки DirectX - это компонент ОС Windows, предназначенный для работы с мультимедиа - игры, музыка, фильмы - всё это работает в большинстве случаев благодаря DirectX. 

	Зачем PLR необходим DirectX?
	PLRenewer использует DirectX для воспроизведения аудио-треков (закладка Мини-плеер). Но, поскольку PLR - это программа, использующая ресурсы унифицированной платформы .Net Framework, ей требуются совместимые с .Net библиотеки поддержки DirectX. Они называются Managed (управляемый) DirectX (MDX).

	Как установить MDX в систему?
	Изначально корпорация Microsoft распространяла MDX отдельно в виде небольшого пакета, но уже несколько лет файлы поддержки MDX входят в установщик DirectX. Когда вы обновляете DirectX на своём компьютере, если установщик находит установленный .Net Framework, он автоматически скопирует файлы MDX. А .Net Framework у вас установлен просто потому что эта программа вообще запустилась :)

	Как начать установку?
	Если у вас есть установщик последнего DirectX (за июнь 2010 года), просто запустите его - и через минуту файлы MDX будут установлены в вашу систему. Если же установщика у вас нет или вы используете одну из предыдущих версий DirectX, вы можете скачать его по прямой ссылке ниже. Ещё одна ссылка ведёт на страницу с описанием этого файла, и вы сможете убедиться, что обе ссылки идентичны. Третья ссылка скопирует в буфер обмена ссылку на установщик.

	Что если запустить старую версию установщика DirectX?
	PLR тестировался с пакетом MDX версии 1.0.2911.0, входящими в состав установок DirectX с апреля 2006 до июня 2010 включительно. Насчёт более ранних сборок никаких гарантий нет. Тем не менее всегда рекомендуется поддерживать актуальность версии DirectX на вашем компьютере - это повышает производительность, устраняет уязвимости системы и уменьшает количество ошибок DirectX-приложений.

	Что будет, если не ставить MDX вообще?
	В комплекте с PLR поставляются 2 основные библиотеки MDX, используемые для воспроизведения музыки. Известно, что на Windows7/Server Se7en х86/х64 они загружаются и работают стабильно и музыку воспроизводят. Насчёт остальных платформ на данный момент информация отсутствует. Никаких гарантий на стабильную работу PLR без установки MDX не существует. PLR не тестируется без установленного MDX на Windows XP и Server 2003R2 (и вообще не тестируется на Vista/Server 2008).</value>
  </data>
</root>